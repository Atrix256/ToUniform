#include <random>
#include <vector>
#include "pcg/pcg_basic.h"

#define DETERMINISTIC() false

static const size_t c_numberCount = 10000000;

float PCGRandomFloat01(pcg32_random_t& rng)
{
	return ldexpf((float)pcg32_random_r(&rng), -32);
}

float UniformToLinear(float x)
{
	// PDF In:  y = 1
	// PDF Out: y = 2x
	// ICDF:    y = sqrt(x)
	return std::sqrt(x);
}

float LinearToUniform(float x)
{
	// PDF In:  y = 2x
	// PDF Out: y = 1 PDF out
	// ICDF:    y = x*x
	return x*x;
}

// https://www.shadertoy.com/view/4t2SDh
float UniformToTriangle(float nrnd0)
{
	auto fract = [](float f) { return f - std::floor(f); };
	auto inversesqrt = [](float f) { return 1.0f / sqrt(f); };
	auto sign = [](float f) { return f < 0.0f ? -1.0f : 1.0f; };

	float input = nrnd0;

	nrnd0 = fract(nrnd0 + 0.5f);

	float orig = nrnd0 * 2.0f - 1.0f;
	nrnd0 = orig * inversesqrt(abs(orig));
	nrnd0 = std::max(-1.0f, nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
	nrnd0 = nrnd0 - sign(orig) + 0.5f;

	if (nrnd0 < -1.0f)
	{
		if (input < 0.5f)
			nrnd0 = -0.5f;
		else
			nrnd0 = 1.5f;
	}

	// convert from [-0.5, 1.5] to [0,1]
	nrnd0 = (nrnd0 + 0.5f) / 2.0f;

	return nrnd0;
}

float TriangleToUniform(float x)
{
	if (x < 0.5f)
	{
		x = LinearToUniform(x * 2.0f) / 2.0f;
	}
	else
	{
		x = 1.0f - x;
		x = LinearToUniform(x * 2.0f) / 2.0f;
		x = 1.0f - x;
	}

	return x;
}

float Factorial(int n)
{
	if (n <= 2)
		return 1.0f;

	float ret = 1.0f;
	for (int i = 2; i <= n; ++i)
		ret *= float(i);
	return ret;
}

float NChooseK(int n, int k)
{
	return Factorial(n) / (Factorial(k) * Factorial(n - k));
}

// N is the number of uniform random values added together.
// x is the value to put through the CDF and is in [0, N]
float IrwinHallCDF(int N, float x)
{
	float oneOverNFactorial = 1.0f / Factorial(N);
	
	float sum = 0.0f;
	for (int k = 0; k <= int(x); ++k)
	{
		float sign = (k & 1) ? -1.0f : 0.0f;
		float term = sign * NChooseK(N, k);
		term = term * pow(x - float(k), float(N));
		sum += term;
	}

	return oneOverNFactorial * sum;
}

int main(int argc, char** argv)
{
	pcg32_random_t rng;
#if !DETERMINISTIC()
	std::random_device rd;
	pcg32_srandom_r(&rng, rd(), 0);
#else
	pcg32_srandom_r(&rng, 0xa000b800, 0);
#endif

	// Make uniform random numbers
	std::vector<float> uniform(c_numberCount);
	for (float& f : uniform)
		f = PCGRandomFloat01(rng);

	// Convert them to linear
	std::vector<float> uniformToLinear = uniform;
	for (float& f : uniformToLinear)
		f = UniformToLinear(f);

	// Convert back to uniform
	std::vector<float> uniformToLinearToUniform = uniformToLinear;
	for (float& f : uniformToLinearToUniform)
		f = LinearToUniform(f);

	// Convert from uniform to triangular
	std::vector<float> uniformToTriangle = uniform;
	for (float& f : uniformToTriangle)
		f = UniformToTriangle(f);

	// Convert back to uniform
	std::vector<float> uniformToTriangleToUniform = uniformToTriangle;
	for (float& f : uniformToTriangleToUniform)
		f = TriangleToUniform(f);

	// make triangular red noise through addition (low pass filter)
	std::vector<float> order2RedNoise(c_numberCount);
	{
		float a[2] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 2] = PCGRandomFloat01(rng);
			order2RedNoise[i] = a[0] + a[1];
			order2RedNoise[i] = order2RedNoise[i] / 2.0f;
		}
	}

	// Convert to uniform
	std::vector<float> order2RedNoiseToUniform = order2RedNoise;
	for (float& f : order2RedNoiseToUniform)
		f = TriangleToUniform(f);

	// make triangular blue noise through subtraction (high pass filter)
	std::vector<float> order2BlueNoise(c_numberCount);
	{
		float a[2] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 2] = PCGRandomFloat01(rng);
			order2BlueNoise[i] = a[i % 2] - a[(i + 1) % 2];
			order2BlueNoise[i] = (1.0f + order2BlueNoise[i]) / 2.0f;
		}
	}

	// Convert to uniform
	std::vector<float> order2BlueNoiseToUniform = order2BlueNoise;
	for (float& f : order2BlueNoiseToUniform)
		f = TriangleToUniform(f);

	// order 3 blue noise through subtraction (high pass filter)
	std::vector<float> order3BlueNoise(c_numberCount);
	{
		float a[3] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 3] = PCGRandomFloat01(rng);

			bool plus = true;
			order3BlueNoise[i] = 0.0f;
			for (int j = 0; j < 3; ++j)
			{
				order3BlueNoise[i] += a[(i + j) % 3] * (plus ? 1.0f : -1.0f);
				plus = !plus;
			}

			order3BlueNoise[i] = (order3BlueNoise[i] + 1.0f) / 3.0f;
		}
	}

	// order 4 blue noise through subtraction (high pass filter)
	std::vector<float> order4BlueNoise(c_numberCount);
	{
		float a[4] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 4] = PCGRandomFloat01(rng);

			bool plus = true;
			order4BlueNoise[i] = 0.0f;
			for (int j = 0; j < 4; ++j)
			{
				order4BlueNoise[i] += a[(i + j) % 4] * (plus ? 1.0f : -1.0f);
				plus = !plus;
			}

			order4BlueNoise[i] = (order4BlueNoise[i] + 2.0f) / 4.0f;
		}
	}

	// order 5 blue noise through subtraction (high pass filter)
	std::vector<float> order5BlueNoise(c_numberCount);
	{
		float a[5] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 5] = PCGRandomFloat01(rng);

			bool plus = true;
			order5BlueNoise[i] = 0.0f;
			for (int j = 0; j < 5; ++j)
			{
				order5BlueNoise[i] += a[(i + j) % 5] * (plus ? 1.0f : -1.0f);
				plus = !plus;
			}

			order5BlueNoise[i] = (order5BlueNoise[i] + 2.0f) / 5.0f;
		}
	}

	// order 3 red noise through addition (low pass filter)
	std::vector<float> order3RedNoise(c_numberCount);
	{
		float a[3] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 3] = PCGRandomFloat01(rng);
			order3RedNoise[i] = a[0] + a[1] + a[2];
			order3RedNoise[i] = order3RedNoise[i] / 3.0f;
		}
	}

	// order 4 red noise through addition (low pass filter)
	std::vector<float> order4RedNoise(c_numberCount);
	{
		float a[4] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 4] = PCGRandomFloat01(rng);
			order4RedNoise[i] = a[0] + a[1] + a[2] + a[3];
			order4RedNoise[i] = order4RedNoise[i] / 4.0f;
		}
	}

	// order 5 red noise through addition (low pass filter)
	std::vector<float> order5RedNoise(c_numberCount);
	{
		float a[5] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 5] = PCGRandomFloat01(rng);
			order5RedNoise[i] = a[0] + a[1] + a[2] + a[3] + a[4];
			order5RedNoise[i] = order5RedNoise[i] / 5.0f;
		}
	}

	// order 5 add sub noise
	std::vector<float> order5AddSubNoise(c_numberCount);
	{
		float a[5] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 5] = PCGRandomFloat01(rng);
			order5AddSubNoise[i] = a[0] + a[1] - a[2] - a[3] - a[4];
			order5AddSubNoise[i] = (order5AddSubNoise[i] + 3.0f) / 5.0f;
		}
	}

	// order 5 add sub weighted noise
	std::vector<float> order5AddSubWeightedNoise(c_numberCount);
	{
		float a[5] = { PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng), PCGRandomFloat01(rng) };
		for (size_t i = 0; i < c_numberCount; ++i)
		{
			a[i % 5] = PCGRandomFloat01(rng);
			order5AddSubWeightedNoise[i] = 0.5f * a[0] + 0.2f * a[1] - 0.3f * a[2] - 0.6f * a[3] - 0.1f * a[4];
			order5AddSubWeightedNoise[i] = (order5AddSubWeightedNoise[i] + 1.0f) / 1.7f;

			// + 0.5, 0.2 = 0.7
			// - 0.3, 0.6, 0.1 = 1.0
		}
	}

	// write to a csv so we can make histograms
	FILE* file = nullptr;
	fopen_s(&file, "out.csv", "wb");
	fprintf(file,
		"\"Uniform\","
		"\"UniformToLinear\",\"UniformToLinearToUniform\","
		"\"UniformToTriangle\",\"UniformToTriangleToUniform\","
		"\"order2RedNoise\",\"order2RedNoiseToUniform\","
		"\"Order3RedNoise\",\"Order4RedNoise\",\"Order5RedNoise\","
		"\"order2BlueNoise\",\"order2BlueNoiseToUniform\","
		"\"Order3BlueNoise\",\"Order4BlueNoise\",\"Order5BlueNoise\","
		"\"Order5AddSubNoise\",\"Order5AddSubWeightedNoise\""
		"\n"
	);
	for (size_t i = 0; i < c_numberCount; ++i)
		fprintf(file,
			"\"%f\","
			"\"%f\",\"%f\","
			"\"%f\",\"%f\","
			"\"%f\",\"%f\","
			"\"%f\",\"%f\",\"%f\","
			"\"%f\",\"%f\","
			"\"%f\",\"%f\",\"%f\","
			"\"%f\",\"%f\""
			"\n",
			uniform[i],
			uniformToLinear[i], uniformToLinearToUniform[i],
			uniformToTriangle[i], uniformToTriangleToUniform[i],
			order2RedNoise[i], order2RedNoiseToUniform[i],
			order3RedNoise[i], order4RedNoise[i], order5RedNoise[i],
			order2BlueNoise[i], order2BlueNoiseToUniform[i],
			order3BlueNoise[i], order4BlueNoise[i], order5BlueNoise[i],
			order5AddSubNoise[i], order5AddSubWeightedNoise[i]
	);
	fclose(file);

	return 0;
}

/*
TODO:
- new repo? ToUniform2
- better DFTs by averaging a bunch of smaller sections.
- irwin hall distribution
- LUT for irwin hall CDF, or least squares polynomial fit?

- mix adding and subtracting
- weight terms (gaussian?)

? what is irwin hall for weighted values? or aka uniform that is within different ranges

*/
